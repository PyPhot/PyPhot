import gc, os
import numpy as np
import numpy.ma as ma

from astropy import wcs
from astropy.io import fits
from astropy.table import Table, vstack
from astropy.stats import SigmaClip, sigma_clip
from astropy.stats import gaussian_fwhm_to_sigma
from astropy.convolution import Gaussian2DKernel
from astropy.coordinates import SkyCoord
from astropy import units as u

from photutils import detect_sources
from photutils import deblend_sources
from photutils import source_properties
from photutils.utils import calc_total_error
from photutils import SkyCircularAperture
from photutils import aperture_photometry

from photutils import StdBackgroundRMS, MADStdBackgroundRMS, BiweightScaleBackgroundRMS
from photutils import Background2D, MeanBackground, MedianBackground, SExtractorBackground
from photutils import MMMBackground, BiweightLocationBackground, ModeEstimatorBackground

from pyphot import msgs, sex
from pyphot import crossmatch


def BKG2D(data, back_size, mask=None, filter_size=(3, 3), sigclip=5, back_type='median', back_rms_type='std',
          back_maxiters=5, sextractor_task='sex'):

    ## Sky background subtraction

    if back_type.lower() == 'median':
        bkg_estimator = MedianBackground()
    elif back_type.lower() == 'mean':
        bkg_estimator = MeanBackground()
    elif back_type.lower() == 'sextractor':
        #bkg_estimator = SExtractorBackground()
        bkg_estimator = 'sextractor'
    elif back_type.lower() == 'mmm':
        bkg_estimator = MMMBackground()
    elif back_type.lower() == 'biweight':
        bkg_estimator = BiweightLocationBackground()
    elif back_type.lower() == 'mode':
        bkg_estimator = ModeEstimatorBackground()
    else:
        msgs.warn('{:} Background is not found, using MedianBackground Instead.'.format(back_type))
        back_type = 'median'
        bkg_estimator = MedianBackground()

    if back_rms_type.lower() == 'std':
        bkgrms_estimator = StdBackgroundRMS()
    elif back_rms_type.lower() == 'mad':
        bkgrms_estimator = MADStdBackgroundRMS()
    elif back_rms_type.lower() == 'biweight':
        bkgrms_estimator = BiweightScaleBackgroundRMS()
    else:
        msgs.warn('{:} Background RMS type is not found, using STD Instead.'.format(back_rms_type))
        bkgrms_estimator = StdBackgroundRMS()

    if bkg_estimator == 'sextractor':
        msgs.info('Estimating BACKGROUND with SExtractor.')
        tmp_root = 'mask_bright_star_tmp_{:03d}'.format(np.random.randint(1,9999))

        # perform rejections
        tmp_data = ma.masked_array(data, mask=mask, fill_value=np.nan)
        filtered_data = sigma_clip(tmp_data, sigma=sigclip, maxiters=back_maxiters, masked=True)
        tmp_data = data.copy()
        tmp_data[filtered_data.mask] = np.nan
        par = fits.PrimaryHDU(tmp_data)
        par.writeto('{:}.fits'.format(tmp_root),overwrite=True)

        # configuration for the first SExtractor run
        sexconfig = {"CHECKIMAGE_TYPE": "BACKGROUND, BACKGROUND_RMS", "WEIGHT_TYPE": "NONE", "CATALOG_TYPE": "FITS_LDAC",
                      "CHECKIMAGE_NAME":"{:}_bkg.fits, {:}_rms.fits".format(tmp_root,tmp_root),
                      "DETECT_THRESH": 5, "ANALYSIS_THRESH": 5, "DETECT_MINAREA": 5,
                      "BACK_SIZE": '{:},{:}'.format(back_size[0],back_size[1]),
                     "BACK_FILTERSIZE":'{:},{:}'.format(filter_size[0],filter_size[1])}
        sexparams = ['NUMBER', 'X_IMAGE', 'Y_IMAGE', 'XWIN_IMAGE', 'YWIN_IMAGE', 'ERRAWIN_IMAGE', 'ERRBWIN_IMAGE',
                      'ERRTHETAWIN_IMAGE', 'ALPHA_J2000', 'DELTA_J2000', 'ISOAREAF_IMAGE', 'ISOAREA_IMAGE', 'ELLIPTICITY',
                      'ELONGATION', 'MAG_AUTO', 'MAGERR_AUTO', 'FLUX_AUTO', 'FLUXERR_AUTO', 'MAG_APER', 'MAGERR_APER']
        sex.sexone('{:}.fits'.format(tmp_root), task=sextractor_task, config=sexconfig, workdir='./', params=sexparams,
                   defaultconfig='pyphot', conv='sex', nnw=None, dual=False, delete=True, log=False)
        bkg_map = fits.getdata("{:}_bkg.fits".format(tmp_root))
        rms_map = fits.getdata("{:}_rms.fits".format(tmp_root))
        msgs.info('Removing temporary files generated by SExtractor')
        os.system('rm {:}.fits'.format(tmp_root))
        os.system('rm {:}_bkg.fits'.format(tmp_root))
        os.system('rm {:}_rms.fits'.format(tmp_root))
        os.system('rm {:}_cat.fits'.format(tmp_root))
    else:
        msgs.info('Estimating {:} BACKGROUND with Photutils Background2D.'.format(back_type))
        tmp = data.copy()
        Sigma_Clip = SigmaClip(sigma=sigclip, maxiters=back_maxiters)
        bkg = Background2D(tmp, back_size, mask=mask, filter_size=filter_size, sigma_clip=Sigma_Clip,
                           bkg_estimator=bkg_estimator, bkgrms_estimator=bkgrms_estimator)
        bkg_map, rms_map = bkg.background, bkg.background_rms
        del tmp, bkg
        gc.collect()

    return bkg_map, rms_map


def photutils_detect(data, wcs_info=None, rmsmap=None, bkgmap=None, mask=None,
                     effective_gain=None, nsigma=2., npixels=5, fwhm=5, zpt=0.,
                     nlevels=32, contrast=0.001, back_nsigma=3, back_maxiters=10, back_type='median', back_rms_type='std',
                     back_size=(200, 200), back_filter_size=(3, 3), morp_filter=False, sextractor_task='sex',
                     phot_apertures=[1.0,2.0,3.0,4.0,5.0], return_seg_only=False):
    '''
        Detect sources from a FITS image
    Args:
        data:
        wcs_info:
        rmsmap:
        bkgmap:
        mask:
        effective_gain (float or 2D array): should be a 2D map of exposure time
        nsigma (int or float): how many sigma of your detection
        npixels:  Letâ€™s find sources that have 5 connected pixels that are each greater than the
                  corresponding pixel-wise threshold level defined above  (i.e., 2 sigma per pixel above the background noise)
        fwhm (int or float): seeing in units of pixel
        nlevels:
        contrast:
        back_nsigma:
        back_maxiters:
        back_type:
        back_rms_type:
        back_box_size:
        back_filter_size:
        morp_filter (bool): whether you want to use the kernel filter when measuring morphology and centroid
                            If set true, it should be similar with SExtractor. False gives a better morphology
    Returns:
        astropy Table
    '''

    if mask is None:
        mask = np.isinf(data)

    if effective_gain is None:
        effective_gain = 1.0

    if (rmsmap is None) or (bkgmap is None):
        background_array, background_rms = BKG2D(data, back_size, mask=mask, filter_size=back_filter_size,
                                                 sigclip=back_nsigma, back_type=back_type, back_rms_type=back_rms_type,
                                                 back_maxiters=back_maxiters, sextractor_task=sextractor_task)
        if rmsmap is None:
            rmsmap = background_rms
        if bkgmap is None:
            bkgmap = background_array

    threshold = bkgmap + nsigma * rmsmap
    error = calc_total_error(data,rmsmap, effective_gain)

    ## Build a Gaussian kernel
    sigma = fwhm * gaussian_fwhm_to_sigma
    kernel = Gaussian2DKernel(sigma, x_size=3, y_size=3)
    kernel.normalize()

    ## Do the detection using the Image Segmentation technique
    ## The return is a SegmentationImage
    msgs.info('Detecting targets with detect_sources')
    segm = detect_sources(data, threshold, npixels=npixels, filter_kernel=kernel)

    if return_seg_only:
        return segm

    # Source Deblending
    msgs.info('Deblending with deblend_sources')
    segm_deblend = deblend_sources(data, segm, npixels=npixels, filter_kernel=kernel,
                                   nlevels=nlevels, contrast=contrast)

    # Check the Seg image
    '''
    import matplotlib.pyplot as plt
    from astropy.visualization import SqrtStretch
    from astropy.visualization.mpl_normalize import ImageNormalize
    image_norm = ImageNormalize(stretch=SqrtStretch())

    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 12.5))
    ax1.imshow(data, origin='lower', cmap='Greys_r', norm=image_norm)
    ax1.set_title('Data')
    cmap = segm.make_cmap(random_state=123)
    ax2.imshow(segm, origin='lower', cmap=cmap, interpolation='nearest')
    ax2.set_title('Segmentation Image')
    '''

    ## measure the source properties
    msgs.info('Measuring source properties with source_properties')
    if morp_filter:
        cat = source_properties(data, segm_deblend, mask=mask, background=bkgmap, error=error,
                                filter_kernel=kernel, wcs=wcs_info)
    else:
        cat = source_properties(data, segm_deblend, mask=mask, background=bkgmap, error=error, wcs=wcs_info)
    tbl = cat.to_table()
    tbl = tbl[np.invert(np.isnan(tbl['xcentroid']))] # remove sources with nan positions
    tbl['MAG_AUTO'] = -2.5*np.log10(tbl['source_sum']) + zpt
    tbl['MAGERR_AUTO'] = 2.5/np.log(10)*tbl['source_sum_err']/tbl['source_sum']
    tbl['FLUX_AUTO'] = tbl['source_sum']
    tbl['FLUXERR_AUTO'] = tbl['source_sum_err']

    ## Perform Aperture photometry
    msgs.info('Performing Aperture photometry')
    positions = tbl['sky_centroid']
    apertures = [SkyCircularAperture(positions, r=d/2*u.arcsec) for d in phot_apertures]
    tbl_aper = aperture_photometry(data, apertures, error=error, mask=mask, method='exact', wcs=wcs_info)
    flux_aper = np.zeros((len(tbl_aper), np.size(phot_apertures)))
    fluxerr_aper = np.zeros_like(flux_aper)
    mag_aper = np.zeros_like(flux_aper)
    magerr_aper = np.zeros_like(flux_aper)
    for ii in range(np.size(phot_apertures)):
        flux_aper[:,ii] = tbl_aper['aperture_sum_{:d}'.format(ii)]
        fluxerr_aper[:,ii] = tbl_aper['aperture_sum_err_{:d}'.format(ii)]
        mag_aper[:,ii] =  -2.5*np.log10(tbl_aper['aperture_sum_{:d}'.format(ii)]) + zpt
        magerr_aper[:,ii] = 2.5/np.log(10)*tbl_aper['aperture_sum_err_{:d}'.format(ii)]/tbl_aper['aperture_sum_{:d}'.format(ii)]
    tbl['MAG_APER'] = mag_aper
    tbl['MAGERR_APER'] = magerr_aper
    tbl['FLUX_APER'] = flux_aper
    tbl['FLUXERR_APER'] = fluxerr_aper

    ## ToDo: Add PSF photometry

    return tbl, rmsmap, bkgmap

def mask_bright_star(data, mask=None, brightstar_nsigma=3, back_nsigma=3, back_maxiters=10, npixels=5, fwhm=5,
                     method='sextractor', task='sex'):

    if mask is not None:
        data[mask] = 0. # zero out bad pixels

    if method.lower()=='photoutils':
        msgs.info('Masking bright stars with Photoutils')
        tmp = data.copy()
        back_box_size = (tmp.shape[0] // 10, tmp.shape[1] // 10)
        seg = photutils_detect(tmp, nsigma=brightstar_nsigma, npixels=npixels, fwhm=fwhm,
                               back_type='median', back_rms_type='mad', back_nsigma=back_nsigma, back_maxiters=back_maxiters,
                               back_size=back_box_size, back_filter_size=(3, 3), return_seg_only=True)
        mask = seg.data>0
        del tmp, seg
        gc.collect()
    else:
        msgs.info('Masking bright stars with SExtractor.')
        tmp_root = 'mask_bright_star_tmp_{:03d}'.format(np.random.randint(1,999))
        par = fits.PrimaryHDU(data)
        par.writeto('{:}.fits'.format(tmp_root),overwrite=True)
        # configuration for the first SExtractor run
        sexconfig0 = {"CHECKIMAGE_TYPE": "OBJECTS", "WEIGHT_TYPE": "NONE", "CATALOG_NAME": "dummy.cat",
                      "CATALOG_TYPE": "FITS_LDAC",
                      "CHECKIMAGE_NAME":"{:}_check.fits".format(tmp_root),
                      "DETECT_THRESH": brightstar_nsigma,
                      "ANALYSIS_THRESH": brightstar_nsigma,
                      "DETECT_MINAREA": npixels}
        sexparams0 = ['NUMBER', 'X_IMAGE', 'Y_IMAGE', 'XWIN_IMAGE', 'YWIN_IMAGE', 'ERRAWIN_IMAGE', 'ERRBWIN_IMAGE',
                      'ERRTHETAWIN_IMAGE', 'ALPHA_J2000', 'DELTA_J2000', 'ISOAREAF_IMAGE', 'ISOAREA_IMAGE',
                      'ELLIPTICITY',
                      'ELONGATION', 'MAG_AUTO', 'MAGERR_AUTO', 'FLUX_AUTO', 'FLUXERR_AUTO', 'MAG_APER', 'MAGERR_APER']
        sex.sexone('{:}.fits'.format(tmp_root), task=task, config=sexconfig0, workdir='./', params=sexparams0,
                   defaultconfig='pyphot', conv='sex', nnw=None, dual=False, delete=True, log=False)
        data_check = fits.getdata("{:}_check.fits".format(tmp_root))
        mask = data_check>0
        msgs.info('Removing temporary files generated by SExtractor')
        os.system('rm {:}.fits'.format(tmp_root))
        os.system('rm {:}_check.fits'.format(tmp_root))
        os.system('rm {:}_cat.fits'.format(tmp_root))

    return mask

def ForcedAperPhot(catalogs, images, rmsmaps, flagmaps, outfile=None, phot_apertures=[1.0,2.0,3.0,4.0,5.0], cat_ids=None, unique_dist=1.0):

    ncat = np.size(catalogs)
    if cat_ids is None:
        cat_ids = (np.arange(ncat)+1).astype('U').tolist()
    assert ncat == np.size(images), 'The numbers of images and catalogs should be the same'
    assert ncat == np.size(cat_ids), 'The numbers of cat_ids and catalogs should be the same'

    if rmsmaps is not None:
        assert ncat == np.size(rmsmaps), 'The numbers of images and rmsmaps should be the same'
    if flagmaps is not None:
        assert ncat == np.size(flagmaps), 'The numbers of images and flagmaps should be the same'

    ## Merge catalogs
    Table_Merged= Table.read(catalogs[0], 2)
    Table_Merged['CAT_ID'] = cat_ids[0]
    for icat in range(1,ncat):
        table_icat = Table.read(catalogs[icat], 2)
        table_icat['CAT_ID'] = cat_ids[icat]

        pos1 = np.zeros((len(Table_Merged), 2))
        try:
            pos1[:, 0], pos1[:, 1] = Table_Merged['ALPHA_J2000'],Table_Merged['DELTA_J2000']
        except:
            pos1[:, 0], pos1[:, 1] = Table_Merged['sky_centroid_icrs.ra'],Table_Merged['sky_centroid_icrs.dec']

        pos2 = np.zeros((len(table_icat), 2))
        try:
            pos2[:, 0], pos2[:, 1] = table_icat['ALPHA_J2000'],table_icat['DELTA_J2000']
        except:
            pos2[:, 0], pos2[:, 1] = table_icat['sky_centroid_icrs.ra'],table_icat['sky_centroid_icrs.dec']

        ## cross-match with 1 arcsec
        dist, ind = crossmatch.crossmatch_angular(pos2, pos1, max_distance=unique_dist / 3600.)
        no_match = np.isinf(dist)
        Table_Merged =vstack([Table_Merged, table_icat[no_match]])

    ## Prepare the output forced photometry catalog
    ## ToDo: Currently only used the posotions and flags of the merged catalog is included.
    ##       Next step is to keep all the origin columns of the input catalog
    Table_Forced = Table()
    Table_Forced['CAT_ID'] = Table_Merged['CAT_ID']
    Table_Forced['FORCED_ID'] = (np.arange(len(Table_Forced))+1).astype('int32')
    try:
        Table_Forced['RA'], Table_Forced['DEC']= Table_Merged['ALPHA_J2000'],Table_Merged['DELTA_J2000']
    except:
        Table_Forced['RA'], Table_Forced['DEC'] = Table_Merged['sky_centroid_icrs.ra'], Table_Merged['sky_centroid_icrs.dec']

    if 'CLASS_STAR' in Table_Merged.keys():
        Table_Forced['CLASS_STAR'] = Table_Merged['CLASS_STAR']
    if 'FLAGS' in Table_Merged.keys():
        Table_Forced['FLAGS'] = Table_Merged['FLAGS']
    if 'IMAFLAGS_ISO' in Table_Merged.keys():
        Table_Forced['IMAFLAGS_ISO'] = Table_Merged['IMAFLAGS_ISO']
    if 'NIMAFLAGS_ISO' in Table_Merged.keys():
        Table_Forced['NIMAFLAGS_ISO'] = Table_Merged['NIMAFLAGS_ISO']

    ## Let's perform the forced aperture photometry on each image
    positions = SkyCoord(ra=Table_Forced['RA'], dec=Table_Forced['DEC'], unit=(u.deg, u.deg))

    ## Perform aperture photometry for all merged sources
    for ii, this_image in enumerate(images):
        msgs.info('Performing forced aperture photometry on {:}'.format(this_image))
        data = fits.getdata(this_image)
        header = fits.getheader(this_image)
        wcs_info = wcs.WCS(header)

        try:
            zpt = header['ZP']
        except:
            zpt = 0.

        if flagmaps is not None:
            ## good pixels with flag==0
            flag = fits.getdata(flagmaps[ii])
            mask = flag > 0.
        else:
            mask = None

        if rmsmaps is not None:
            error = fits.getdata(rmsmaps[ii])
        else:
            error = None

        apertures = [SkyCircularAperture(positions, r=d/2*u.arcsec) for d in phot_apertures]
        tbl_aper = aperture_photometry(data, apertures, error=error, mask=mask, method='exact', wcs=wcs_info)
        flux_aper = np.zeros((len(tbl_aper), np.size(phot_apertures)))
        fluxerr_aper = np.zeros_like(flux_aper)
        mag_aper = np.zeros_like(flux_aper)
        magerr_aper = np.zeros_like(flux_aper)
        for jj in range(np.size(phot_apertures)):
            flux_aper[:,jj] = tbl_aper['aperture_sum_{:d}'.format(jj)]
            fluxerr_aper[:,jj] = tbl_aper['aperture_sum_err_{:d}'.format(jj)]
            mag_aper[:,jj] =  -2.5*np.log10(tbl_aper['aperture_sum_{:d}'.format(jj)])
            magerr_aper[:,jj] = 2.5/np.log(10)*tbl_aper['aperture_sum_err_{:d}'.format(jj)]/tbl_aper['aperture_sum_{:d}'.format(jj)]

        Table_Forced['FORCED_XCENTER_{:}'.format(cat_ids[ii])] = tbl_aper['xcenter']
        Table_Forced['FORCED_YCENTER_{:}'.format(cat_ids[ii])] = tbl_aper['ycenter']
        #Table_Forced['FORCED_SKY_CENTER_{:}'.format(cat_ids[ii])] = tbl_aper['sky_center']
        Table_Forced['FORCED_MAG_APER_{:}'.format(cat_ids[ii])] = mag_aper + zpt
        Table_Forced['FORCED_MAGERR_APER_{:}'.format(cat_ids[ii])] = magerr_aper
        Table_Forced['FORCED_FLUX_APER_{:}'.format(cat_ids[ii])] = flux_aper
        Table_Forced['FORCED_FLUXERR_APER_{:}'.format(cat_ids[ii])] = fluxerr_aper

        badmag = np.isinf(mag_aper) | np.isnan(mag_aper)
        Table_Forced['FORCED_MAG_APER_{:}'.format(cat_ids[ii])][badmag] = 99.
        Table_Forced['FORCED_MAGERR_APER_{:}'.format(cat_ids[ii])][badmag] = 99.

        badphot = (flux_aper == 0.)
        Table_Forced['FORCED_FLAG_APER_{:}'.format(cat_ids[ii])] = np.sum(badphot,axis=1)

    if outfile is not None:
        Table_Forced.write(outfile,format='fits', overwrite=True)

    return Table_Forced